# main.py

import asyncio
import logging
import os
import sys
import json
import sqlite3
from datetime import date, timedelta
from cryptography.fernet import Fernet

# --- –ù–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ ---
# pip install aiogram google-generativeai garminconnect stravalib cryptography

import requests
import google.generativeai as genai
from aiogram import Bot, Dispatcher, F, types
from aiogram.enums import ParseMode
from aiogram.filters import Command, CommandStart
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.client.default import DefaultBotProperties
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton

from stravalib.client import Client
from garminconnect import Garmin

# ==============================================================================
# 1. –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ò –ù–ê–°–¢–†–û–ô–ö–ò
# ==============================================================================

# --- –ö–ª—é—á–∏ –∏ —Ç–æ–∫–µ–Ω—ã (–í–ê–ñ–ù–û: –ó–ê–ü–û–õ–ù–ò–¢–ï –≠–¢–ò –ü–û–õ–Ø) ---
TELEGRAM_BOT_TOKEN = "8062193958:AAGjIUkYG_YCjsWrfgs6TDzK3SU7_e8QnZI"
GEMINI_API_KEY = "AIzaSyDMsXs9h8jAyo7GRIMxoLv0_p2peb3cUXw"
# –ö–ª—é—á, —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–Ω–µ–µ. –ï—Å–ª–∏ —É –≤–∞—Å –µ–≥–æ –Ω–µ—Ç, —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –Ω–æ–≤—ã–π.
ENCRYPTION_KEY = b'jgKPVRDS3T_n80PN-ldK8zwoSytl7cZYbO3DpW48hdg='

# --- –û–±—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ ---
DB_FILE = 'ai_coach.db'
POLL_INTERVAL_SECONDS = 3600  # –ü—Ä–æ–≤–µ—Ä—è—Ç—å —Ä–∞–∑ –≤ —á–∞—Å

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –∫–ª–∏–µ–Ω—Ç–æ–≤ API ---
logging.basicConfig(level=logging.INFO, stream=sys.stdout, format='%(asctime)s - %(levelname)s - %(message)s')
os.environ['SILENCE_TOKEN_WARNINGS'] = 'true'
cipher_suite = Fernet(ENCRYPTION_KEY)

try:
    genai.configure(api_key=GEMINI_API_KEY)
except Exception as e:
    logging.error(f"–û—à–∏–±–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ Gemini: {e}. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ API-–∫–ª—é—á.")


# ==============================================================================
# 2. –°–õ–û–ô –ë–ê–ó–´ –î–ê–ù–ù–´–• (SQLITE)
# ==============================================================================

def get_db_connection():
    conn = sqlite3.connect(DB_FILE)
    conn.row_factory = sqlite3.Row
    return conn

def init_db():
    with get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute('CREATE TABLE IF NOT EXISTS users (telegram_id INTEGER PRIMARY KEY, full_name TEXT, username TEXT)')
        cursor.execute('CREATE TABLE IF NOT EXISTS credentials (id INTEGER PRIMARY KEY, user_id INTEGER, service TEXT, creds_json TEXT, UNIQUE(user_id, service))')
        cursor.execute('CREATE TABLE IF NOT EXISTS processed_workouts (workout_id TEXT PRIMARY KEY, user_id INTEGER, analysis_text TEXT)')
        cursor.execute('CREATE TABLE IF NOT EXISTS friends (id INTEGER PRIMARY KEY, user_id_1 INTEGER, user_id_2 INTEGER, status TEXT, UNIQUE(user_id_1, user_id_2))') # status: 'pending', 'accepted'
        conn.commit()
        logging.info("–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞.")

def encrypt_creds(creds: dict) -> str:
    return cipher_suite.encrypt(json.dumps(creds).encode('utf-8')).decode('utf-8')

def decrypt_creds(encrypted_creds: str) -> dict:
    return json.loads(cipher_suite.decrypt(encrypted_creds.encode('utf-8')))

def get_user_credentials(user_id):
    with get_db_connection() as conn:
        return conn.execute("SELECT service, creds_json FROM credentials WHERE user_id = ?", (user_id,)).fetchall()

def save_user_credentials(user_id, service, creds):
    encrypted_creds = encrypt_creds(creds)
    with get_db_connection() as conn:
        conn.execute("INSERT OR REPLACE INTO credentials (user_id, service, creds_json) VALUES (?, ?, ?)",
                     (user_id, service, encrypted_creds))
        conn.commit()

def delete_user_credentials(user_id, service):
    with get_db_connection() as conn:
        conn.execute("DELETE FROM credentials WHERE user_id = ? AND service = ?", (user_id, service))
        conn.commit()

def is_workout_processed(workout_id):
    with get_db_connection() as conn:
        return conn.execute("SELECT 1 FROM processed_workouts WHERE workout_id = ?", (workout_id,)).fetchone() is not None

def save_processed_workout(workout_id, user_id, analysis_text):
    with get_db_connection() as conn:
        conn.execute("INSERT OR REPLACE INTO processed_workouts (workout_id, user_id, analysis_text) VALUES (?, ?, ?)", (workout_id, user_id, analysis_text))
        conn.commit()

# --- –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥—Ä—É–∑—å—è–º–∏ ---
def add_friend_request(user_id_1, user_id_2):
    with get_db_connection() as conn:
        if not conn.execute("SELECT 1 FROM users WHERE telegram_id = ?", (user_id_2,)).fetchone(): return "not_found"
        existing = conn.execute("SELECT * FROM friends WHERE (user_id_1 = ? AND user_id_2 = ?) OR (user_id_1 = ? AND user_id_2 = ?)",
                                (user_id_1, user_id_2, user_id_2, user_id_1)).fetchone()
        if existing: return "already_exists"
        conn.execute("INSERT INTO friends (user_id_1, user_id_2, status) VALUES (?, ?, 'pending')", (user_id_1, user_id_2))
        conn.commit()
        return "ok"

def get_user_friends(user_id):
    with get_db_connection() as conn:
        return conn.execute("""
            SELECT u.telegram_id, u.full_name FROM friends f
            JOIN users u ON u.telegram_id = CASE WHEN f.user_id_1 = ? THEN f.user_id_2 ELSE f.user_id_1 END
            WHERE (f.user_id_1 = ? OR f.user_id_2 = ?) AND f.status = 'accepted'
        """, (user_id, user_id, user_id)).fetchall()

def get_friend_requests(user_id):
    with get_db_connection() as conn:
        incoming = conn.execute("SELECT u.telegram_id, u.full_name FROM friends f JOIN users u ON u.telegram_id = f.user_id_1 WHERE f.user_id_2 = ? AND f.status = 'pending'", (user_id,)).fetchall()
        outgoing = conn.execute("SELECT u.telegram_id, u.full_name FROM friends f JOIN users u ON u.telegram_id = f.user_id_2 WHERE f.user_id_1 = ? AND f.status = 'pending'", (user_id,)).fetchall()
        return {"incoming": incoming, "outgoing": outgoing}

def update_friend_request(user_id_1, user_id_2, new_status):
    with get_db_connection() as conn:
        if new_status == 'accepted':
            conn.execute("UPDATE friends SET status = ? WHERE user_id_1 = ? AND user_id_2 = ?", (new_status, user_id_1, user_id_2))
        elif new_status == 'declined':
            conn.execute("DELETE FROM friends WHERE (user_id_1 = ? AND user_id_2 = ?) OR (user_id_1 = ? AND user_id_2 = ?)", (user_id_1, user_id_2, user_id_2, user_id_1))
        conn.commit()

# ==============================================================================
# 3. –°–õ–û–ô –°–ï–†–í–ò–°–û–í (STRAVA, GARMIN, SUUNTO)
# ==============================================================================
def get_strava_data(creds: dict):
    workouts = []
    try:
        client = Client(access_token=creds['access_token'])
        activities = client.get_activities(limit=10)
        for activity in activities:
            workouts.append({
                "id": f"strava_{activity.id}", "service": "Strava", "name": activity.name,
                "type": str(activity.type), "date": activity.start_date_local.strftime("%Y-%m-%d %H:%M"),
                "distance_km": round(activity.distance.to("km").magnitude, 2),
                "duration_min": round(activity.elapsed_time.total_seconds() / 60),
                "avg_hr": activity.average_heartrate,
            })
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö Strava: {e}")
    return workouts

def get_garmin_data(creds: dict):
    workouts = []
    try:
        api = Garmin(creds['email'], creds['password'])
        api.login()
        activities = api.get_activities_by_date(
            (date.today() - timedelta(days=7)).isoformat(), date.today().isoformat()
        )
        for activity in activities:
            workouts.append({
                "id": f"garmin_{activity.get('activityId')}", "service": "Garmin", "name": activity.get('activityName', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'),
                "type": activity.get('activityType', {}).get('typeKey', 'N/A'), "date": activity.get('startTimeLocal', ''),
                "distance_km": round(activity.get("distance", 0) / 1000, 2),
                "duration_min": round(activity.get("duration", 0) / 60), "avg_hr": activity.get('averageHR'),
            })
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö Garmin: {e}")
    return workouts

def get_suunto_data(creds: dict):
    workouts = []
    try:
        headers = {"Authorization": f"Bearer {creds['access_token']}", "Ocp-Apim-Subscription-Key": creds['api_key']}
        response = requests.get("https://cloudapi.suunto.com/v2/workouts", headers=headers)
        response.raise_for_status()
        for activity in response.json():
            workouts.append({
                "id": f"suunto_{activity.get('workoutKey')}", "service": "Suunto", "name": activity.get('activityName', 'N/A'),
                "type": activity.get('activityName', 'N/A'), "date": activity.get('startTime'),
                "distance_km": round(activity.get('totalDistance', 0) / 1000, 2),
                "duration_min": round(activity.get('totalDuration', 0) / 60), "avg_hr": activity.get('avgHr'),
            })
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö Suunto: {e}")
    return workouts

SERVICE_MAP = {'strava': get_strava_data, 'garmin': get_garmin_data, 'suunto': get_suunto_data}

# ==============================================================================
# 4. –°–õ–û–ô –ê–ù–ê–õ–ò–ó–ê (GEMINI AI)
# ==============================================================================
async def analyze_workout_with_gemini(workout_data: dict, friend_context: str = "") -> str:
    try:
        model = genai.GenerativeModel('gemini-2.5-pro')
        prompt = f"""–¢—ã ‚Äî –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ò–ò-—Ç—Ä–µ–Ω–µ—Ä. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –¥–∞–Ω–Ω—ã–µ –æ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ. –î–∞–π –∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ –∏ –ø–æ–ª–µ–∑–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏. {friend_context}
        –î–∞–Ω–Ω—ã–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏:
        - –°–µ—Ä–≤–∏—Å: {workout_data.get('service', 'N/A')}
        - –¢–∏–ø: {workout_data.get('type', 'N/A')}
        - –î–∏—Å—Ç–∞–Ω—Ü–∏—è: {workout_data.get('distance_km', 'N/A')} –∫–º
        - –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {workout_data.get('duration_min', 'N/A')} –º–∏–Ω
        - –°—Ä–µ–¥–Ω–∏–π –ø—É–ª—å—Å: {workout_data.get('avg_hr', 'N/A')} —É–¥/–º–∏–Ω
        """
        response = await model.generate_content_async(prompt)
        return response.text
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –≤ Gemini: {e}")
        return "–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É."

# ==============================================================================
# 5. –õ–û–ì–ò–ö–ê –ë–û–¢–ê (AIOGRAM HANDLERS & FSM)
# ==============================================================================
bot = Bot(token=TELEGRAM_BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()

class AddService(StatesGroup):
    choosing_service = State()
    entering_creds_1 = State()
    entering_creds_2 = State()

class FriendStates(StatesGroup):
    adding_friend = State()

# --- –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã ---
main_menu_keyboard = InlineKeyboardMarkup(inline_keyboard=[
    [InlineKeyboardButton(text="‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–∏—Å–∞–º–∏", callback_data="manage_services")],
    [InlineKeyboardButton(text="üë• –ú–æ–∏ –¥—Ä—É–∑—å—è", callback_data="friends_menu")],
    [InlineKeyboardButton(text="üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤—Ä—É—á–Ω—É—é", callback_data="fetch_manual")]
])

def services_menu_keyboard(user_id):
    creds = get_user_credentials(user_id)
    buttons = [[InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–µ—Ä–≤–∏—Å", callback_data="add_service")]]
    for cred in creds:
        buttons.append([InlineKeyboardButton(text=f"‚ùå –£–¥–∞–ª–∏—Ç—å {cred['service'].capitalize()}", callback_data=f"delete_service_{cred['service']}")])
    buttons.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_main_menu")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)

def friends_menu_keyboard(requests_count):
    text = f"üì® –ó–∞—è–≤–∫–∏ –≤ –¥—Ä—É–∑—å—è ({requests_count})" if requests_count > 0 else "üì® –ó–∞—è–≤–∫–∏ –≤ –¥—Ä—É–∑—å—è"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="ü§ù –°–ø–∏—Å–æ–∫ –¥—Ä—É–∑–µ–π", callback_data="list_friends")],
        [InlineKeyboardButton(text=text, callback_data="friend_requests")],
        [InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –¥—Ä—É–≥–∞", callback_data="add_friend")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_main_menu")]
    ])

# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ ---
@dp.message(CommandStart())
async def command_start(message: Message):
    user_id, full_name, username = message.from_user.id, message.from_user.full_name, message.from_user.username
    with get_db_connection() as conn:
        conn.execute("INSERT OR IGNORE INTO users (telegram_id, full_name, username) VALUES (?, ?, ?)", (user_id, full_name, username))
        conn.execute("UPDATE users SET full_name = ?, username = ? WHERE telegram_id = ?", (full_name, username, user_id))
        conn.commit()
    await message.answer(f"–ü—Ä–∏–≤–µ—Ç, {full_name}! –ß—Ç–æ —Ö–æ—á–µ—à—å —Å–¥–µ–ª–∞—Ç—å?", reply_markup=main_menu_keyboard)

@dp.message(Command("myid"))
async def show_my_id(message: Message):
    """
    –≠—Ç–æ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –µ–≥–æ Telegram ID.
    """
    user_id = message.from_user.id
    await message.answer(f"–í–∞—à Telegram ID: <code>{user_id}</code>\n\n"
                         "–≠—Ç–æ—Ç ID –Ω—É–∂–µ–Ω, —á—Ç–æ–±—ã –¥—Ä—É–≥–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –º–æ–≥–ª–∏ –¥–æ–±–∞–≤–∏—Ç—å –≤–∞—Å –≤ –¥—Ä—É–∑—å—è.")

@dp.callback_query(F.data == "back_to_main_menu")
async def back_to_main_menu_callback(callback: CallbackQuery):
    await callback.message.edit_text("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.", reply_markup=main_menu_keyboard)
    await callback.answer()

# --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–∏—Å–∞–º–∏ ---
@dp.callback_query(F.data == "manage_services")
async def manage_services_callback(callback: CallbackQuery):
    await callback.message.edit_text("–ó–¥–µ—Å—å –≤—ã –º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∏–ª–∏ —É–¥–∞–ª–∏—Ç—å —Å–≤–æ–∏ —Ñ–∏—Ç–Ω–µ—Å-—Å–µ—Ä–≤–∏—Å—ã.", reply_markup=services_menu_keyboard(callback.from_user.id))
    await callback.answer()

@dp.callback_query(F.data == "add_service")
async def add_service_callback(callback: CallbackQuery, state: FSMContext):
    await state.set_state(AddService.choosing_service)
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Strava", callback_data="service_strava")],
        [InlineKeyboardButton(text="Garmin", callback_data="service_garmin")],
        [InlineKeyboardButton(text="Suunto", callback_data="service_suunto")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data="cancel_add_service")]
    ])
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–≤–∏—Å –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è:", reply_markup=kb)
    await callback.answer()

@dp.callback_query(F.data.startswith("delete_service_"))
async def delete_service_callback(callback: CallbackQuery):
    service_to_delete = callback.data.split("_")[2]
    delete_user_credentials(callback.from_user.id, service_to_delete)
    await callback.answer(f"–°–µ—Ä–≤–∏—Å {service_to_delete.capitalize()} —É–¥–∞–ª–µ–Ω.", show_alert=True)
    await callback.message.edit_text("–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–µ—Ä–≤–∏—Å–∞–º–∏.", reply_markup=services_menu_keyboard(callback.from_user.id))

@dp.callback_query(F.data == "cancel_add_service")
async def cancel_add_service_callback(callback: CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.edit_text("–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–µ—Ä–≤–∏—Å–∞–º–∏.", reply_markup=services_menu_keyboard(callback.from_user.id))
    await callback.answer()

@dp.callback_query(AddService.choosing_service)
async def process_service_choice(callback: CallbackQuery, state: FSMContext):
    service = callback.data.split("_")[1]
    await state.update_data(service=service)
    await state.set_state(AddService.entering_creds_1)
    prompt_text = {
        'strava': "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à Access Token –æ—Ç Strava.",
        'garmin': "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à Email –æ—Ç Garmin Connect.",
        'suunto': "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à Access Token –æ—Ç Suunto."
    }
    await callback.message.edit_text(prompt_text.get(service, "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å."))
    await callback.answer()

@dp.message(AddService.entering_creds_1)
async def process_creds_1(message: Message, state: FSMContext):
    data = await state.get_data()
    service = data['service']
    await state.update_data(creds_1=message.text)
    if service == 'garmin':
        await state.set_state(AddService.entering_creds_2)
        await message.answer("–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –ø–∞—Ä–æ–ª—å –æ—Ç Garmin Connect.")
    elif service == 'suunto':
        await state.set_state(AddService.entering_creds_2)
        await message.answer("–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à Subscription Key (API Key) –æ—Ç Suunto.")
    else: # Strava
        save_user_credentials(message.from_user.id, service, {'access_token': message.text})
        await message.answer(f"‚úÖ –°–µ—Ä–≤–∏—Å {service.capitalize()} —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!")
        await state.clear()
        await message.answer("–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–µ—Ä–≤–∏—Å–∞–º–∏.", reply_markup=services_menu_keyboard(message.from_user.id))

@dp.message(AddService.entering_creds_2)
async def process_creds_2(message: Message, state: FSMContext):
    data = await state.get_data()
    service, creds_1 = data['service'], data['creds_1']
    creds = {}
    if service == 'garmin':
        creds = {'email': creds_1, 'password': message.text}
    elif service == 'suunto':
        creds = {'access_token': creds_1, 'api_key': message.text}
    save_user_credentials(message.from_user.id, service, creds)
    await message.answer(f"‚úÖ –°–µ—Ä–≤–∏—Å {service.capitalize()} —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!")
    await state.clear()
    await message.answer("–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–µ—Ä–≤–∏—Å–∞–º–∏.", reply_markup=services_menu_keyboard(message.from_user.id))

# --- –°–∏—Å—Ç–µ–º–∞ –¥—Ä—É–∑–µ–π ---
@dp.callback_query(F.data == "friends_menu")
async def friends_menu_callback(callback: CallbackQuery):
    requests = get_friend_requests(callback.from_user.id)
    await callback.message.edit_text("–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥—Ä—É–∑—å—è–º–∏.", reply_markup=friends_menu_keyboard(len(requests['incoming'])))
    await callback.answer()

@dp.callback_query(F.data == "add_friend")
async def add_friend_callback(callback: CallbackQuery, state: FSMContext):
    await state.set_state(FriendStates.adding_friend)
    await callback.message.edit_text("–û—Ç–ø—Ä–∞–≤—å –º–Ω–µ Telegram ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—á–µ—à—å –¥–æ–±–∞–≤–∏—Ç—å.\n\n"
                                     "P.S. ID –º–æ–∂–Ω–æ —É–∑–Ω–∞—Ç—å, –Ω–∞–ø–∏—Å–∞–≤ –º–Ω–µ –∫–æ–º–∞–Ω–¥—É /myid")
    await callback.answer()

@dp.message(FriendStates.adding_friend)
async def process_friend_id(message: Message, state: FSMContext):
    if not message.text.isdigit():
        await message.answer("ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º. –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑.")
        return
    
    friend_id, user_id = int(message.text), message.from_user.id
    if friend_id == user_id:
        await message.answer("–ù–µ–ª—å–∑—è –¥–æ–±–∞–≤–∏—Ç—å –≤ –¥—Ä—É–∑—å—è —Å–∞–º–æ–≥–æ —Å–µ–±—è.")
        return

    result = add_friend_request(user_id, friend_id)
    if result == "ok":
        await message.answer("‚úÖ –ó–∞—è–≤–∫–∞ –≤ –¥—Ä—É–∑—å—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞!")
        try:
            requests = get_friend_requests(friend_id)
            await bot.send_message(friend_id, f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {message.from_user.full_name} —Ö–æ—á–µ—Ç –¥–æ–±–∞–≤–∏—Ç—å –≤–∞—Å –≤ –¥—Ä—É–∑—å—è!",
                                   reply_markup=friends_menu_keyboard(len(requests['incoming'])))
        except Exception as e:
            logging.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞—è–≤–∫–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {friend_id}: {e}")
    elif result == "not_found":
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–æ—Ç–µ.")
    elif result == "already_exists":
        await message.answer("‚ÑπÔ∏è –í—ã —É–∂–µ –¥—Ä—É–∑—å—è —Å —ç—Ç–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º –∏–ª–∏ –∑–∞—è–≤–∫–∞ –±—ã–ª–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ —Ä–∞–Ω–µ–µ.")

    await state.clear()
    requests = get_friend_requests(user_id)
    await message.answer("–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥—Ä—É–∑—å—è–º–∏.", reply_markup=friends_menu_keyboard(len(requests['incoming'])))

@dp.callback_query(F.data == "friend_requests")
async def friend_requests_callback(callback: CallbackQuery):
    requests = get_friend_requests(callback.from_user.id)
    text = "<b>–í—Ö–æ–¥—è—â–∏–µ –∑–∞—è–≤–∫–∏:</b>\n"
    kb_buttons = []
    if not requests['incoming']: text += "–ü—É—Å—Ç–æ\n"
    else:
        for req in requests['incoming']:
            text += f"- {req['full_name']} (ID: {req['telegram_id']})\n"
            kb_buttons.append([
                InlineKeyboardButton(text=f"‚úÖ –ü—Ä–∏–Ω—è—Ç—å {req['full_name']}", callback_data=f"friend_accept_{req['telegram_id']}"),
                InlineKeyboardButton(text=f"‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"friend_decline_{req['telegram_id']}")
            ])
    text += "\n<b>–ò—Å—Ö–æ–¥—è—â–∏–µ –∑–∞—è–≤–∫–∏:</b>\n"
    if not requests['outgoing']: text += "–ü—É—Å—Ç–æ"
    else:
        for req in requests['outgoing']: text += f"- {req['full_name']} (ID: {req['telegram_id']})\n"
    kb_buttons.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é –¥—Ä—É–∑–µ–π", callback_data="friends_menu")])
    await callback.message.edit_text(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=kb_buttons))
    await callback.answer()

@dp.callback_query(F.data.startswith("friend_accept_"))
async def accept_friend_callback(callback: CallbackQuery):
    friend_id, user_id = int(callback.data.split("_")[2]), callback.from_user.id
    update_friend_request(friend_id, user_id, 'accepted')
    await callback.answer("‚úÖ –ó–∞—è–≤–∫–∞ –ø—Ä–∏–Ω—è—Ç–∞!")
    await bot.send_message(friend_id, f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {callback.from_user.full_name} –ø—Ä–∏–Ω—è–ª –≤–∞—à—É –∑–∞—è–≤–∫—É –≤ –¥—Ä—É–∑—å—è!")
    await friend_requests_callback(callback)

@dp.callback_query(F.data.startswith("friend_decline_"))
async def decline_friend_callback(callback: CallbackQuery):
    friend_id, user_id = int(callback.data.split("_")[2]), callback.from_user.id
    update_friend_request(friend_id, user_id, 'declined')
    await callback.answer("‚ùå –ó–∞—è–≤–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.")
    await friend_requests_callback(callback)

@dp.callback_query(F.data == "list_friends")
async def list_friends_callback(callback: CallbackQuery):
    friends = get_user_friends(callback.from_user.id)
    text = "<b>–°–ø–∏—Å–æ–∫ –≤–∞—à–∏—Ö –¥—Ä—É–∑–µ–π:</b>\n"
    kb_buttons = []
    if not friends: text += "–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –¥—Ä—É–∑–µ–π."
    else:
        for friend in friends:
            text += f"- {friend['full_name']}\n"
            kb_buttons.append([InlineKeyboardButton(text=f"üìä –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å {friend['full_name']}", callback_data=f"view_friend_{friend['telegram_id']}")])
    kb_buttons.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é –¥—Ä—É–∑–µ–π", callback_data="friends_menu")])
    await callback.message.edit_text(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=kb_buttons))
    await callback.answer()

@dp.callback_query(F.data.startswith("view_friend_"))
async def view_friend_activity_callback(callback: CallbackQuery):
    friend_id = int(callback.data.split("_")[2])
    with get_db_connection() as conn:
        last_workout = conn.execute("SELECT analysis_text FROM processed_workouts WHERE user_id = ? ORDER BY rowid DESC LIMIT 1", (friend_id,)).fetchone()
        friend = conn.execute("SELECT full_name FROM users WHERE telegram_id = ?", (friend_id,)).fetchone()
    if last_workout and last_workout['analysis_text']:
        await callback.answer()
        await callback.message.answer(f"<b>–ü–æ—Å–ª–µ–¥–Ω–∏–π –∞–Ω–∞–ª–∏–∑ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ –¥–ª—è {friend['full_name']}:</b>\n\n{last_workout['analysis_text']}")
    else:
        await callback.answer("–£ —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –µ—â–µ –Ω–µ—Ç –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫.", show_alert=True)

# --- –†—É—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ ---
@dp.callback_query(F.data == "fetch_manual")
async def fetch_manual_callback(callback: CallbackQuery):
    await callback.message.edit_text("‚è≥ –ù–∞—á–∏–Ω–∞—é –ø—Ä–æ–≤–µ—Ä–∫—É –≤—Ä—É—á–Ω—É—é...", reply_markup=None)
    await check_user_workouts(bot, callback.from_user.id)
    await callback.message.edit_text("‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!", reply_markup=main_menu_keyboard)
    await callback.answer("–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")

# ==============================================================================
# 6. –§–û–ù–û–í–´–ô –ü–õ–ê–ù–ò–†–û–í–©–ò–ö (SCHEDULER)
# ==============================================================================
async def check_user_workouts(bot: Bot, user_id: int):
    user_creds = get_user_credentials(user_id)
    if not user_creds: return

    all_workouts = []
    for service, encrypted_creds_json in user_creds:
        try:
            creds = decrypt_creds(encrypted_creds_json)
            if service in SERVICE_MAP:
                all_workouts.extend(SERVICE_MAP[service](creds))
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {service} —É {user_id}: {e}")

    for workout in all_workouts:
        if not is_workout_processed(workout['id']):
            logging.info(f"–ù–∞–π–¥–µ–Ω–∞ –Ω–æ–≤–∞—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –¥–ª—è {user_id}: {workout['id']}")
            try:
                await bot.send_message(user_id, f"üí™ –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –Ω–æ–≤–∞—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞: <b>{workout.get('name', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')}</b>! –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é...")
                analysis_text = await analyze_workout_with_gemini(workout)
                save_processed_workout(workout['id'], user_id, analysis_text)
                await bot.send_message(user_id, f"<b>ü§ñ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –æ—Ç –ò–ò-—Ç—Ä–µ–Ω–µ—Ä–∞:</b>\n\n{analysis_text}")
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")


async def scheduler(bot: Bot):
    while True:
        await asyncio.sleep(POLL_INTERVAL_SECONDS)
        logging.info("–ó–∞–ø—É—Å–∫ –ø–ª–∞–Ω–æ–≤–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫...")
        with get_db_connection() as conn:
            users = conn.execute("SELECT telegram_id FROM users").fetchall()
        for user in users:
            await check_user_workouts(bot, user['telegram_id'])
        

# ==============================================================================
# 7. –¢–û–ß–ö–ê –í–•–û–î–ê
# ==============================================================================
async def main():
    init_db()
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –∑–∞–¥–∞—á—É
    asyncio.create_task(scheduler(bot))

    logging.info("–ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")
    # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –±–æ—Ç —É–¥–∞–ª–∏—Ç –≤–µ–±—Ö—É–∫ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º –≤ —Ä–µ–∂–∏–º–µ –ø–æ–ª–ª–∏–Ω–≥–∞
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        logging.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")
